
//Put at very end of constructor of CNT class to check if segments match up with the actual 

	string pathjon = "C:/Users/Gabory/Dropbox/Research/OutputFiles/positions.csv";
	ofstream f;
	f.open(pathjon);
	int endjon = segs->size();
	for (int i = 0; i < endjon; i++)
	{
		segment ts = (*segs)[i];
		f << ts.p1(0, 0);
		f << ",";
		f << ts.p1(1, 0);
		f << ",";
		f << ts.p1(2, 0);
		f << "\n";
		f << ts.mid(0, 0);
		f << ",";
		f << ts.mid(1, 0);
		f << ",";
		f << ts.mid(2, 0);
		f << "\n";

	}
	segment ts = (*segs)[segs->size() - 1];
	f << ts.p2(0, 0);
	f << ",";
	f << ts.p2(1, 0);
	f << ",";
	f << ts.p2(2, 0);
	f << "\n";

	f.close();

//Put at top of main, comment out all other code in main
	double v[] = { .02, .1, .15, .2, .25, .3, .38, .49, .51, .69, .71, .88, .99, 1 };
	vector<double> val(v, v + sizeof(v) / sizeof(v[0]));
	static const double t1[] = { .1, .2, .3, .5, .7, 1 }; //ans: 0,0,1,1,2,2,3,3,4,4,5,5,5,5
	vector<double> t11(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	shared_ptr<vector<double>> yo1(&t11);
	static const double t2[] = { .4, 1 };
	vector<double> t22(t2, t2 + sizeof(t2) / sizeof(t2[0])); //ans: 0,0,0,0,0,0,0,1,1,1,1,1,1,1
	shared_ptr<vector<double>> yo2(&t22);
	static const double t3[] = { .567, .669, 1 };
	vector<double> t33(t3, t3 + sizeof(t3) / sizeof(t3[0])); //ans:0,0,0,0,0,0,0,0,0,2,2,2,2,2
	shared_ptr<vector<double>> yo3(&t33);
	static const double t4[] = { .323, .567, .669, .858, 1 };
	vector<double> t44(t4, t4 + sizeof(t4) / sizeof(t4[0])); //ans:0,0,0,0,0,0,1,1,1,3,3,4,4,4
	shared_ptr<vector<double>> yo4(&t44);

	//code works for these cases

	int size = val.size();
	cout << "Responses from t1:\n";
	for (int i = 0; i < size; i++)
	{
		cout << getIndex(yo1, val[i]) << endl;
	}


	cout << "\nResponses from t2:\n";
	for (int i = 0; i < size; i++)
	{
		cout << getIndex(yo2, val[i]) << endl;
	}


	cout << "\nResponses from t3:\n";
	for (int i = 0; i < size; i++)
	{
		cout << getIndex(yo3, val[i]) << endl;
	}


	cout << "\nResponses from t4:\n";
	for (int i = 0; i < size; i++)
	{
		cout << getIndex(yo4, val[i]) << endl;
	}


	system("pause");

//Checks if the exciton code is working for segments
	shared_ptr<exciton> ex1(new exciton(0, 0, 1));
	shared_ptr<exciton> ex2(new exciton(0, 0, 1));
	shared_ptr<exciton> ex3(new exciton(0, 0, 2));
	shared_ptr<exciton> ex4(new exciton(0, 0, 2));
	shared_ptr<vector<segment>> currSeg = (*CNT_List)[0].segs;
	bool result = (*currSeg)[0].setExciton(ex1);
	result = (*currSeg)[0].setExciton(ex2);
	result = (*currSeg)[0].setExciton(ex3);
	bool remres = (*currSeg)[0].removeExciton(ex3);
	remres = (*currSeg)[0].removeExciton(ex3);
	result = (*currSeg)[0].setExciton(ex4);



	//Tests removal of an object from an array.
	shared_ptr<vector<double>> temp = make_shared<vector<double>>(0);
	temp->push_back((2.0));
	temp->push_back((5.0));
	temp->push_back((6.0));
	temp->push_back((2.6));
	temp->push_back((7.1));
	temp->push_back((1.6));
	temp->push_back((4.8));
	temp->push_back((6.7));
	temp->push_back((92.1));
	temp->push_back((8.4));
	temp->push_back((2.0));
	temp->push_back((8.4));

	int numRem = 2;
	if (numRem > 0)
	{
		for (int i = 0; i < temp->size(); i++)
		{
			if (((*temp)[i]) == 2.0)
			{
				double temp2 = (*temp)[temp->size() - 1];
				(*temp)[temp->size() - 1] = (*temp)[i];
				(*temp)[i] = temp2;
				temp->pop_back();
				//temp->erase(temp->begin() + i);
				i--;
			}
		}
	}


	//Tests to see if openMP works

	#define NUM_START 1
#define NUM_END 10
		int i, nRet = 0, nSum = 0, nStart = NUM_START, nEnd = NUM_END;
	int nThreads = 0, nTmp = nStart + nEnd;
	unsigned uTmp = (unsigned((abs(nStart - nEnd) + 1)) *
		unsigned(abs(nTmp))) / 2;
	int nSumCalc = uTmp;

	if (nTmp < 0)
		nSumCalc = -nSumCalc;

	omp_set_num_threads(NUM_THREADS);

#pragma omp parallel default(none) private(i) shared(nSum, nThreads, nStart, nEnd)
	{
#pragma omp master
		nThreads = omp_get_num_threads();

#pragma omp for
		for (i = nStart; i <= nEnd; ++i) {
#pragma omp atomic
			nSum += i;
		}
	}

	if (nThreads == NUM_THREADS) {
		printf_s("%d OpenMP threads were used.\n", NUM_THREADS);
		nRet = 0;
	}
	else {
		printf_s("Expected %d OpenMP threads, but %d were used.\n",
			NUM_THREADS, nThreads);
		nRet = 1;
	}

	if (nSum != nSumCalc) {
		printf_s("The sum of %d through %d should be %d, "
			"but %d was reported!\n",
			NUM_START, NUM_END, nSumCalc, nSum);
		nRet = 1;
	}
	else{
		printf_s("The sum of %d through %d is %d\n",
			NUM_START, NUM_END, nSum);
	}
